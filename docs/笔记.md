## 什么是 React

### react 的核心价值

react 核心价值： 组件化 + 数据驱动视图

- 组件化：拆分页面结构，通过组件拼装页面，对组件进行复用；易开发易维护。
- 数据驱动视图：定义好数据和 UI 的格式，即 UI = f(state)，这个 f 函数就是 react 做的事情，我们只需要关心数据和 UI 结构，不用再操作 DOM，增加开发效率。

## 创建 React 项目开发环境

### 准备工作

安装 nodejs（使用 nvm 安装）、切换国内 npm 镜像、使用 vscode、安装 git

### 使用 cra 创建项目

```
npx create-react-app cra-ts-deme --template typescript
```

### 使用 vite 创建项目

```
npm create vite@latest vite-ts-demo -- --template react-ts
```

### 编码规范

先安装 vscode 插件：eslint、prettier

1. eslint - 检查语法语义

   - 安装相关插件
     ```
     npm install eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev
     ```
   - 创建配置文件
     执行命令 `npx eslint --init` 安装 eslint-plugin-react，并生成配置文件 `.eslintrc.js`
   - 创建命令
     添加一条命令，执行该命令时使用 eslint 检查 `src` 目录下相应文件的语法
     ```
     "lint": "eslint 'src/\*_/_.+(js|ts|jsx|tsx)' "
     ```

2. prettier - 检查编码风格

   - 安装相关插件
     ```
     npm install prettier eslint-config-prettier eslint-plugin-prettier --save-dev
     ```
   - 创建配置文件
     1. 先修改 eslint 配置文件，在 `extends` 末尾加上 `"plugin:prettier/recommended"` 插件
     2. 创建 `.vscode/settings.json`（本项目的 vscode 配置文件），保存的时候格式化代码
     ```json
     // 本项目中的vscode配置
     {
       "editor.codeActionsOnSave": {
         // 保存的时候使用eslint修改文档内容（eslint中配置有prettier，所以会使用prettier格式化代码）
         "source.fixAll.eslint": true
       }
     }
     ```
     3. 创建 prettier 的配置文件 `.prettierrc.js`
   - 创建命令
     添加一条命令，执行该命令时使用 prettier 检查 `src` 目录下相应文件的格式并修改（`--write` 的意思就是直接修改）
     ```
     "format": " prettier --write 'src/**/*.+(js|ts|jsx|tsx)' "
     ```

3. husky - 一个 git hook 工具，可以在 git commit 之前执行自定义的命令，如检查代码风格，避免提交非规范的代码

   - 安装插件 `npm install husky -D `
   - 添加并执行命令 `"prepare": "husky install"`
   - 配置 husky 文件，在执行 commit 之前执行 lint 和 format：
     ```
     npx husky add .husky/pre-commit "npm lint"
     npx husky add .husky/pre-commit "npm format"
     // 因为format在代码不规范时会重写代码，所以需要再次git add .
     npx husky add .husky/pre-commit "git add ."
     ```

4. commit-lint - commit 描述的格式规范
   - 安装插件：@commitlint/cli、@commitlint/config-conventional
   - 创建 commit-lint 配置文件：`commitlint.config.js`
     ```js
     /**
      * build: 构建
        chore: 杂活
        ci：持续集成
        docs：文档
        feat：功能
        fix：修复bug
        perf：性能优化
        refactor：重构
        revert：回退
        style：样式
        test：测试
       */
     module.exports = { extends: ["@commitlint/config-conventional"] };
     ```
   - 在 husky 中添加 commitlint 流程：`npx husky add .husky/commit-msg  'npx --no -- commitlint --edit ${1}'`

### vite 和 webpack 的区别

#### Vite

1. Vite 优点

- Vite 启动项目快、热更新快

  1. 启动快：

  - 只启动一台静态页面的服务器，对文件代码不打包；
  - Vite 的原理是借助了浏览器对 ESM 规范的支持；

  2. 热更新快

  - 本地开发环境，在监听到文件变化以后，直接**通过 ws 连接**，通知浏览器去重新加载变化的文件；
  - 在 Vite 中，HMR 是在原生 ESM 上执行的;

2. Vite 的缺点

- 首屏加载慢、懒加载慢

  1. 首屏加载

  - 没有对文件进行 bundle 操作，会导致**大量的 http 请求**
  - dev 服务运行期间会对源文件做转换操作，需要时间
  - 尽管预构建很快，但是也会阻塞首屏的加载

  2. 懒加载

  - 和首屏加载一样，动态加载的文件需要对源文件进行转换操作
  - 还可能会有大量的 http 请求，懒加载的性能同样会受到影响

3. Vite 生产环境

- Vite 在生产环境是需要打包的
- 使用 rollup 进行打包，它相比于 esbuild 在代码分割方面更优秀
- HTTP 请求过多：尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下

#### Webpack

原理：从一个或多个入口点构建一个依赖图(dependency graph)

1. webpack 优点

- 首屏加载、懒加载
  - 由于 dev 启动过程中已经完成整个打包操作，直接将构建好的首屏内容发送给浏览器，不存在性能问题；
  - 也是由于进行了打包操作，所以的依赖在 dev 构建过程中都得以处理，懒加载也不存在问

2. webpack 缺点

   复杂应用的情况下：本地启动时间会比较长、热更新的反应速度比较慢

- 本地启动时间长：

  - 由于本地开发环境，webpack 也会先进行打包，然后再在服务器运行项目，所以如果项目庞大就会出现启动慢的情况
  - webpack 的打包机制：webpack 在 dev 启动的时候，会将项目中各种类型的源文件，转化供浏览器识别的 js、css、img 等文件，并且建立源文件之间的依赖关系，合并为少量的几个文件输出
    webpack 在构建的过程中，会涉及大量的文件 IO、源文件文件转换等操作；并且在分解依赖图的时候，还需要进行遍历操作、文件操作；所以如果项目越大，所需要花费的时间也自然就多

- 热更新慢

  - 一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活，但它也仍需要整个重新构建并重载页面。
    这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热替换（HMR）：允许一个模块 “热替换” 它自己，而不会影响页面其余部分。这大大改进了开发体验；然而，在实践中我们发现，即使采用了 HMR 模式，其热更新速度也会随着应用规模的增长而显著下降。

## JSX 语法和组件基础

### 标签

- 大写字母开头的标签是自定义组件，小写字母开头的标签是 html 元素
- 每段 JSX 只能有一个根结点（可以在最外层使用 Fragment 标签，不会向 DOM 添加额外节点）
- 注意标签的 typescript 类型

> 常见的 DOM 元素类型：`Element`、`HTMLElement`、`HTMLInputElement`、`HTMLButtonElement`、`HTMLDivElement`、`HTMLFormElement`、`HTMLImageElement` 等

### 属性

- class 要改成 `className`（因为 `class` 是关键字，为避免冲突改成了 `className` ）
- style 要使用 JS 对象（不能是 string），而且 `key` 要用驼峰写法
- for 要改成 `htmlFor`（同样的，因为 `for` 是关键字，所以改成 `htmlFor`）

### 事件

- 使用 `onXxx` 的形式
- **事件必须传入一个函数（是 fn，而非`fn()`）**
- 注意事件的 typescript 类型

> 常见的内置事件类型（T 是元素类型）：
> `React.MouseEvent<T = Element>` 鼠标事件对象（例如点击事件）
> `React.ChangeEvent<T = Element>` Change 事件对象（例如 submit 事件等）
> `React.TouchEvent<T = Element>` 触摸事件对象
> `React.ClipboardEvent<T = Element>` 剪贴板事件对象
> `React.DragEvent<T = Element>` 拖拽事件对象
> `React.WheelEvent<T = Element>` 滚轮事件对象
> `React.AnimationEvent<T = Element>` 动画事件对象
> `React.TransitionEvent<T = Element>` 过渡事件对象

> ts 类型拓展：基础类型、函数类型、泛型、class 类型
>
> ```ts
> const n: number = 100;
> function fn<T>(a: T) {}
> class Foo<T> {
>   info: T;
>   setInfo(newInfo: T) {
>     this.info = newInfo;
>   }
> }
> // 将 class 作为类型
> const f1: Foo<string> = new Foo();
> ```

### JS 变量

- 使用 `{xxx}` 插入 JS 变量、函数、表达式
- 可以插入在普通文本、属性里
- 可用于注释

### 条件判断

- 使用逻辑判断符 **`&&`**
- 使用三元表达式
- 使用函数，在函数内部使用条件判断
  ```js
  function App() {
    function ShowHello() {
      if (flag) return null;
      return <p>hello!</p>;
    }
    return (
      <div>
        <ShowHello />
      </div>
    );
  }
  ```

### 循环

- 使用数组 map
- 每个 item 元素需要唯一的 key 属性（不要使用 index）

### 组件和 props

- 组件就是一个 UI 片段
- 拥有独立的逻辑和显式
- 组件可大可小，可嵌套
- 组件可复用
- 自定义组件首字母大写

定义组件和 props 类型：

```ts
import React, { FC } from "react";
type PropsType = {
  id: string;
  title: string;
  isPublished: boolean;
};
const QuestionCard: FC<PropsType> = (props) => {};
```

### React 开发工具 - Chrome 插件

安装插件 React Developer Tools，然后调试就能看到 Components 选项
在这里面可以看到每个 component（自定义组件）的结构关系，及组件内部的 props、state 等信息

### JSX 和 Vue template 的区别

待续.....

## React Hooks

### useState

`useState` 创建组件内部 `state` 及修改该 `state` 的 `setXxx` 方法，**`setXxx` 修改状态时（无论该 `state` 是否被 UI 用到）会触发组件更新**

state 的特点：

- **异步更新**：`setXxx` 后无法立即拿到最新的 state 值
- 可能会被**合并**：
  ```js
  // 每次执行add，count只加1，而不是加3，因为setCount是异步的，setCount()传入的count无法立即获取最新值
  function add() {
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
  }
  // 使用setXxx内部使用函数时，不会被合并；每次执行add，count都加3
  function add() {
    setCount((count) => count + 1);
    setCount((count) => count + 1);
    setCount((count) => count + 1);
  }
  ```
- **不可变数据**：不去修改 `state` 的值，而是传入一个新值
  ```js
  // 修改或新增属性
  setUserInfo({
    ...userInfo,
    age: 21,
  });
  // 新增元素
  setList(list.concat("z"));
  setList([...list, "z"]);
  // 删除元素
  setQuestionList(
    questionList.filter((q) => {
      return q.id !== id;
    })
  );
  ```

为了避免开发过程中忽略了不可变数据原则而导致的 bug，可以使用 **immer** 来规避这一风险；

```js
import { produce } from "immer";
setUserInfo(
  // 可通过 immer 提供的 produce 方法直接修改state
  produce((draft) => {
    draft.age = 21;
  })
);
```

### useEffect

**纯函数**：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，这样的函数被称为纯函数。
**副作用函数**：如果一个函数在运行的过程中，除了返回函数值，还对主调用函数产生附加的影响，这样的函数被称为副作用函数。
`useEffect` 就是在 React 更新 DOM 之后运行一些额外的代码，也就是**执行副作用操作**，比如请求数据，设置订阅以及手动更改 React 组件中的 DOM 等。

`useEffect`接收两个参数，第一个参数是副作用函数，第二个参数是依赖项；

- 不提供依赖数组时，`useEffect` 在每次渲染后都会执行；
- 依赖项为空数组时，`useEffect` 仅在初始化渲染完成时执行一次；
- 依赖项不为空时，`useEffect` 在初始渲染完成和每次依赖项发生变化时执行；
- `useEffect`的第一个参数可以返回一个清理函数。**清理函数会在组件卸载或依赖项发生变化时执行**。如果你返回了一个新函数，它将在下一次 `effect` 执行之前执行。

`useEffect` 执行两次的问题：

- React 18 开始，`useEffect` 在开发环境下会执行两次
- 生产环境下只会执行一次
- 目的是模拟组件创建、销毁、再创建的完整流程，及早暴露问题

### useRef

- 一般用于**操作 DOM**
- **也可传入普通的 JS 变量，但变量更新不会触发 rerender**
- `useRef` 创建的数据通过 `current` 属性取值

#### 异步获取 state 时的闭包陷阱

**当异步函数获取 `state` 时，可能不是当前最新的 `state`，可以通过 `useRef` 来解决**

```js
const Demo: FC = () => {
  const [count, setCount] = useState(0)
  const countRef = useRef(0)
  useEffect(() => {
    countRef.current = count
  }, [count])
  function add() {
    setCount(count + 1)
  }
  function alertFn() {
    // 当点击alert后，三秒内快速点击增加count
    setTimeout(() => {
      alert(count)  // 获取的不是最新值，而是3秒前的count值
      alert(countRef.current) // 可以获取最新的count值
    }, 3000)
  }
  return (...)
}
```

### useMemo

`useMemo` 是性能优化的 hook：

- 使用背景：函数组件每次 `state` 更新时都会重新执行，导致组件内部所有代码都会重新执行。
- `useMemo` 可以**缓存数据**，不用每次执行函数都重新生成；
- 可用于计算量较大的场景，缓存提高性能。

### useCallback

`useCallback` 用于缓存函数：

1. **跳过子组件的重新渲染**：如果将函数作为 `prop` 传递给子组件，当父组件刷新时，子组件由于接收了新的函数引用，会导致子组件没必要的更新渲染，需要将该函数进行缓存
2. **防止频繁触发 Effect**（`useEffect`中调用作为依赖的函数，如果该函数一直重复创建，则`effect`会重复执行）
3. 优化自定义 Hook：**建议将自定义 Hook 返回的任何函数包裹在 `useCallback` 中**

### 自定义 Hooks

公共逻辑的抽离和复用：

- class 组件：Mixin、HOC、render-props
- 函数组件：自定义 Hook

自定义 hook 建议使用`use`开头

### 第三方 Hooks

常用的第三方 hooks：ahooks、react-use

### Hooks 的使用规则

- 必须使用 `useXxx` 格式命名
- 只能在**组件内或者其他 Hook 内**这两个地方调用 Hook
- **必须保证每次的调用顺序一致（不能放在 `if`、`for` 内部）**

## 在 React 中使用 CSS 样式

### 普通方式使用 CSS

1. 内联样式的方式
2. 引入 CSS 文件，配合 `className`设置样式（可以用 `classnames` 插件动态设置 `className`）
3. 尽量少使用内联样式，它的缺点：可维护性差、重复代码、可读性差、无法被缓存（因为它和 html 耦合在一起，外部样式文件可以被缓存）

### CSS-Module 解决 className 可能会重复的问题

普通引入 CSS 文件的方式，可能会出现 `className` 重复的问题，造成样式干扰；
可使用 CSS-module 解决该问题：

1. Create-React-App 原生支持 CSS-Module
2. CSS 文件命名为 `xxx.module.css` 的格式
3. 引入样式文件：`import styles from './xxx.module.css'`
4. 设置 `className`：`<div className={styles['xxx']}></div>`

打包之后实际的类名为：**`组件名_类名_随机字符`**，这样的命名方式既语义化，又能保证类名的唯一性。

**css-module 配合 classnames 使用**：

```js
import styles from "./QuestionCard.module.scss";
const App: FC = () => {
  const listItemClass = styles["list-item"];
  const publishedClass = styles.published;
  // 因为 listItemClass 和 publishedClass 是变量，所以在设置他们的属性时需要用中括号包起来
  const itemClassName = classnames({
    [listItemClass]: true,
    [publishedClass]: isPublished,
  });
  return <div className={itemClassName}></div>;
};
```

### 使用 Sass 提高 CSS 编码效率

- CSS 语法比较原始，不支持嵌套等功能；
- 现在开发一般都会使用 less、sass 等预处理语言；
- CRA 原生支持 **`Sass-Module`【推荐】**，只需要安装 sass 后将样式文件名后缀改成 `.scss` 即可

### CSS-in-JS 常用工具

CSS-in-JS 的特点：

- CSS-in-js 是一种解决方案（而非工具名称），有好几个工具可以实现该方案
- 用 JS 编写 CSS，有逻辑、有变量，非常灵活
- 组件化：**将样式与组件绑定**，每个组件都拥有自己的样式
- Scoped 样式，不会造成样式污染，也不用担心类名重复的问题
- 缺点：将 jsx 和样式代码混在一起，不易于开发和维护；
- 缺点：增加额外的编译成本

常见的 css-in-js 实现工具：`styled-components`、`styled-jsx`、`@emotion/css`

#### styled-components

简单使用：
先安装，然后引入 `styled`、`css` 等方法设置组件的样式

```js
import styled, { css } from "styled-components";

type ButtonPropsType = {
  primary?: boolean,
};
// 创建 Button 组件并设置其样式（可通过模版字符串动态设置样式）
const Button =
  styled.button <
  ButtonPropsType >
  `
  background: transparent;
  border-radius: 3px;
  border: 2px solid #bf4f74;
  color: '#BF4F74';
  margin: 0 1em;
  padding: 0.25em 1em;

  ${(props) =>
    props.primary &&
    css`
      background: palevioletred;
      color: white;
    `};
`;
// 创建 Container 组件并设置其样式
const Container = styled.div`
  text-align: center;
`;
const Demo: FC = () => {
  return (
    <div>
      <Container>
        <Button>正常按钮</Button>
        <Button primary>primary按钮</Button>
      </Container>
    </div>
  );
};
```

> **fn\`xxx\`** 这种方式也是可以执行函数的，例如：
>
> ```js
> function fn(a) {console.log(a)}
> // 执行结果为：123
> fn(123)
> // 执行结果为：['123']
> fn\`123\`
> // 执行结果为：['\n 123\n 456\n']
> fn\`
> 123
> 456
> \`
> ```

#### styled-jsx

`styled-jsx` 同样用于实现 css-in-js，只需要在组件内部的 jsx 中添加一个标签 `<style jsx>{ ... }</style>` 来编写与该组件相关的样式即可。
一个小问题：typescript 会严格检查标签的属性，由于 `style` 标签中不存在 `jsx` 属性，所以直接使用 `<style jsx>` 标签会报错，需要进行额外的类型操作来避免报错。

> `@emotion/css` 的使用方法暂不演示，它和 `styled-jsx` 一样，在 typescript 环境下需要扩展标签的属性，带来一定麻烦。

### Tailwind CSS

Tailwind CSS 是 CSS 样式库，他定义了很多 CSS 样式，只需要设置对应的 className 即可。

## React-router

### 路由设计与 Layout 模版

#### 页面对应的路由

- 首页 `/`
- 登录 `/login`
- 注册 `/register`
- 问卷管理
  - 我的问卷 `/manage/list`
  - 星标问卷 `/manage/star`
  - 回收站 `/manage/trash`
- 问卷详情
  - 编辑问卷 `/question/edit/:id` （动态路由）
  - 问卷统计 `/question/stat/:id`
- 404

#### Layout 模板

- MainLayout 大部分页面的模版（除编辑、统计页）
- ManageLayout （问卷管理左侧都需要导航菜单）
- QuestionLayout （问卷编辑、统计的模版）

**善用 `Outlet` 组件创建 Layout 模版**

### 配置 React-router

```js
import { createBrowserRouter } from "react-router-dom";
import MainLayout from "../layouts/MainLayout";
import Home from "../pages/Home";
const router = createBrowserRouter([
  {
    path: "/",
    element: <MainLayout />,
    children: [
      {
        path: "/",
        element: <Home />,
      },
      ...
    ],
  },
  ...
]);
export default router;
```

### 路由跳转和传参

1. 函数式导航：

```js
import { useNavigate } from "react-router-dom";
const Home: FC = () => {
  const nav = useNavigate();
  function go() {
    nav("/login?a=10");
    // 另一种方式
    nav({
      pathname: "/login",
      search: "a=10",
    });
  }
};
```

2. 链接式导航

```js
import { Link } from "react-router-dom";
const Home: FC = () => {
  return <Link to="/register?a=22">去注册</Link>;
};
```

获取参数：

1. 使用 **`useSearchParams`** 获取 url 中的 search 参数
2. 使用 **`useParams`** 获取动态路由的参数
3. 使用 **`useLocation`** 可以获取到 URL 信息：`{pathname,search,hash,state}`，其中 `state` 是 `push`/`replace` 函数提供的状态对象，用于在导航之间传递数据

## 使用 AntDesign UI 组件库

React 相关 UI 组件库：
国内最常见的 Ant Design、国外非常流行的 Material UI

UI 库：ant-design
图标库： `@ant-design/icons`

常用组件：`Space`、`Layout`（内置`Header`、`Content`、`Sider`、`Footer`等）、`Divider`、`Result`（用于创建 404 页/结果页）、`Button`、`Typography`（内置`Title`、`Paragraph`、`Text`、`Link`等）、Tag、Popconfirm（气泡提示）、Modal（弹窗，替代原生的`window.confirm()`）、message（消息提示，替代原生的`alert()`） 、Empty（空状态时的展示）、Table、表单组件、Spin 等

> 业务优化：分页、搜索、列表数据最好不要有直接联系
>
> - 不好的方式：修改分页/搜索参数就直接请求接口刷新列表页，后果就是刷新页面后会丢失分页和搜索信息
> - 优化：搜索和分页变化后，直接修改 `url` 的 `search` 参数，然后列表页监听 `url` 来更新数据，降低搜索、分页、列表三个组件之间的耦合

## React 表单组件

### 受控组件与非受控组件

- 受控组件：值同步到 `state`，使用 `value` 属性
- 非受控组件：值不同步到 `state`，使用 `defaultValue` 属性
- React 推荐使用受控组件，看似繁琐，但更加可控

### 原生表单组件

#### input 输入框

```ts
// 受控组件
const App: FC = () => {
  const [text, setText] = useState<string>("hello");
  // 监听change事件改变state
  function handleChange(event: ChangeEvent<HTMLInputElement>) {
    setText(event.target.value);
  }
  return (
    <>
      <input value={text} onChange={handleChange} />
    </>
  );
};
```

#### textarea 文字框

- `textarea` 标签的使用和 `input` 输入框差不多：设置 `state`、绑定 `value`、监听 `onChange` 事件动态更新`state`
- `textarea` 支持换行，如果要用 `p` 标签显示文字框里的内容，需要先将 `\n` 替换成 `br` 标签，然后使用 `dangerouslySetInnerHTML` 属性进行渲染。

```ts
const App: FC = () => {
  const [text, setText] = useState<string>("hello");
  function handleChange(event: ChangeEvent<HTMLTextAreaElement>) {
    setText(event.target.value);
  }
  function genHTML() {
    return { __html: text.replaceAll("\n", "<br>") };
  }
  return (
    <>
      <textarea value={text} onChange={handleChange} />
      <p dangerouslySetInnerHTML={getHtml()}></p>
    </>
  );
};
```

#### radio 单选按钮

- `input` 标签设置 `type` 属性为 `radio`，渲染出单选按钮
- 设置 `value` 和监听 `onChange` 事件将其变成受控组件
- 设置 `checked` 属性，设置其选中效果
- 设置 `id` 属性将其与 `label` 标签相关联

```ts
const App: FC = () => {
  const [gender, setGender] = useState("female");
  function handleChange(event: ChangeEvent<HTMLInputElement>) {
    setGender(event.target.value);
  }
  return (
    <div>
      <label htmlFor="radio1">男</label>
      <input
        type="radio"
        id="radio1"
        name="gender"
        value="male"
        checked={gender === "male"}
        onChange={handleChange}
      />
      <label htmlFor="radio2">女</label>
      <input
        type="radio"
        id="radio2"
        name="gender"
        value="female"
        checked={gender === "female"}
        onChange={handleChange}
      />
    </div>
  );
};
```

#### 复选框

- `input` 标签设置 `type` 属性为 `checkbox`，渲染出单选按钮
- 设置 `value` 和监听 `onChange` 事件将其变成受控组件
- 通过 `checked` 属性，设置其选中效果
- 设置 `id` 属性将其与 `label` 标签相关联
- 将 `state` 设置成数组来控制多个复选框
- **添加一个 `type="hidden"` 的 `input` 标签，设置其 `value` 为 `state`，将复选框的数据提交到服务器**

```ts
const App: FC = () => {
  const [selectedCityList, setSelectedCityList] = useState<string[]>([]);
  function handleCityChange(event: ChangeEvent<HTMLInputElement>) {
    const city = event.target.value;
    if (selectedCityList.includes(city)) {
      // 移除
      setSelectedCityList(selectedCityList.filter((c) => c !== city));
    } else {
      // 添加
      setSelectedCityList(selectedCityList.concat(city));
    }
  }
  return (
    <div>
      <label htmlFor="checkbox1">北京</label>
      <input
        type="checkbox"
        id="checkbox1"
        value="shanghai"
        checked={selectedCityList.includes("beijing")}
        onChange={handleCityChange}
      />
      <label htmlFor="checkbox2">上海</label>
      <input
        type="checkbox"
        id="checkbox2"
        value="shanghai"
        checked={selectedCityList.includes("shanghai")}
        onChange={handleCityChange}
      />
      // 提交 checkbox 里的数据
      <input type="hidden" value={JSON.stringify(selectedCityList)} />
    </div>
  );
};
```

#### select 下拉框

- 使用 `select` 标签和 `option` 标签实现下拉框
- 在 `select` 标签上通过 `value`属性 和 `onChange` 事件将其变成受控组件

```ts
const App: FC = () => {
  const [lang, setLang] = useState("js");
  function handleChange(event: ChangeEvent<HTMLSelectElement>) {
    setLang(event.target.value);
  }
  return (
    <>
      <select value={lang} onChange={handleChange}>
        <option value="css">css</option>
        <option value="java">java</option>
        <option value="js">js</option>
      </select>
    </>
  );
};
```

#### form 表单及提交

- 提交的表单数据格式是一个对象，对象的键就是 `name` 属性，键值就是 `value` 属性
- 通过 `type` 为 `submit` 的按钮提交表单数据，默认会把表单数据提交到 `form` 的 `action` 属性所在的服务器上
- 也可以在 `form` 标签上通过 `onSubmit` 属性绑定一个事件来监听 `submit` 行为，在事件里可以**阻止表单的默认提交行为**，然后通过 ajax 自己来提交表单

```ts
const App: FC = () => {
  function handleSubmit(event: ChangeEvent<HTMLFormElement>) {
    event.preventDefault(); // 阻止默认行为，即表单不会再提交数据
    // 可自己通过ajax提交表单
  }
  return (
    <form action="/api/post" onSubmit={handleSubmit}>
      <input name="xxx" value="xxx" />
      <textarea name="xxx" value="xxx" />
      <input type="hidden" name="checkbox" value={checkboxList} />
      <button type="submit"></button>
    </form>
  );
};
```

### Ant Design 表单组件

#### `Form` 组件：

- `labelCol`: label 的宽度
- `wrapperCol`：表单的宽度
- `initialValues`：初始值
- `onFinish`：点击 submit 按钮后的回调事件
- **`form`：通过 `Form.useForm()` 创建的 `form` 控制实例，可通过该实例进行设置表单值、验证、提交、滚动等操作**

```jsx

<Form
  labelCol={{ span: 6 }}
  wrapperCol={{ span: 16 }}
  initialValues={{ remember: true }}
  onFinish={onFinish}
  form={form}
>
```

#### `Form.Item` 组件 - 每一项表单元素：

- **`label`** 属性设置 label 标签
- **`name`** 属性设置提交表单数据时的键
- 如果表单元素是输入框时，默认提交的表单数据的键值就是其 `value` 属性，不用额外设置；但如果表单元素是 `checkbox` 等提交的数据非 `value` 属性的元素时，可通过 **`valuePropName`** 设置该元素真实提交的数据.
- 通过 `wrapperCol={{ offset: 6, span: 16 }}` 设置每一项表单元素的大小

#### 表单校验

- `Form.Item` 通过 `rules` 数组配置校验规则：
- `rules` 的元素为对象时，它各个属性的含义：
  - `pattern`：正则表达式
  - `required`：是否为必选字段
  - `type`：输入类型，例如 `string`、`number`、`email`、`url` 等
  - `min`、`max`：前提是必须设置 `type`；`string` 类型为字符串最大长度；`number` 类型时为最大值；`array` 类型时为数组最大长度
  - `message`：错误信息
- `rules` 的元素为函数时：

  - 该函数接受一个参数：`FormInstance.getFieldValue`，用于获取某表单元素的 value
  - 该函数返回一个对象，对象属性 - **`validator(rule, value) => Promise`** 可用于自定义校验规则

  ```jsx
  <Form.Item
    name="confirm"
    label="Confirm Password"
    dependencies={["password"]} // 依赖项
    hasFeedback
    rules={[
      // 1. rules 的元素为对象
      {
        required: true,
        message: "Please confirm your password!",
      },
      // 2. rules 的元素为函数
      ({ getFieldValue }) => ({
        validator(_, value) {
          if (!value || getFieldValue("password") === value) {
            return Promise.resolve();
          }
          return Promise.reject(
            new Error("The new password that you entered do not match!")
          );
        },
      }),
    ]}
  >
    <Input.Password />
  </Form.Item>
  ```

- `Form.Item` 可以通过 `dependencies` 属性，设置关联字段。当关联字段的值发生变化时，会触发校验与更新。

> 第三方表单校验工具：[React-hook-form](https://react-hook-form.com/)、[Formik](https://formik.org/)

## Ajax 网络请求

### 基础知识、API、工具

#### XMLHttpRequest

**`XMLHttpRequest`** 是一种在客户端和服务器之间进行数据传输的 API：

- **通过回调函数执行异步**
- 可用于发送 http 请求
- 同源策略
- 跨域请求需要配置 CORS

  ```js
  const xhr = new XMLHttpRequest();
  xhr.open("get", ".api/text", true);
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      const result = JSON.parse(xhr.responseText);
    }
  };
  xhr.send();
  ```

#### fetch

**`fetch`** 是基于 Promise 的网络请求 API：

- **Promise 架构**： fetch 返回一个 Promise 对象，使得异步处理更方便
- 简洁的 API

  ```js
  fetch("https://api.example.com/data", {
    method: "POST", // 默认是 GET
    headers: {
      "Content-Type": "application/json",
      // 可以添加其他请求头
    },
    body: JSON.stringify({
      key1: "value1",
      key2: "value2",
    }),
  })
    .then
    // 处理响应
    ()
    .catch
    // 处理错误
    ();
  ```

#### Axios

**`Axios`** 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js 环境：

- 基于 Promise
- 在浏览器环境中，Axios 使用了浏览器原生的 `XMLHttpRequest` 对象来处理网络请求。
- 在 Node.js 环境中，Axios 使用 Node.js 内置的 http 模块来发起请求
- 拦截器（`interceptor`）：在请求或响应被处理前对它们进行拦截和修改
- 取消请求：通过 `Cancel Token` 的机制取消请求

  ```js
  // 1. 创建 Cancel Token 实例
  const source = axios.CancelToken.source();

  axios
    .get("https://api.example.com/data", {
      // 2. 将 Cancel Token 添加到请求配置中
      cancelToken: source.token,
    })
    .then((response) => {
      // 处理响应
    })
    .catch((error) => {
      // 3. 取消请求后给一个提示
      if (axios.isCancel(error)) {
        console.log("Request canceled", error.message);
      } else {
        // 处理其他错误
      }
    });

  // 4. 在需要取消请求的地方调用
  source.cancel("Request canceled by the user");
  ```

### Mock 服务技术选型

mock 服务的重要性：

1. 前后端的并行开发，并非等后端开发完了再开发前端
2. 前后端商议好 API 格式，双方各自开发。前端使用 Mock 服务
3. 前后端开发完了再对接联调

技术选型：

1. 直接使用 mock.js
2. 使用 node 服务 + mock.js
3. 使用在线 mock 平台

> **mockjs 只能劫持 XHR，不能劫持 `fetch`**

#### 直接使用 mock.js【不推荐】

1. 定义模拟的路由及返回结果

```ts
var Mock = require("mockjs");
Mock.mock("/api/test", "get", () => {
  return {
    errno: 0,
    data: {
      name: `solivior ${Date.now()}`,
    },
  };
});
```

2. 在组件中引入并使用 mockjs

```ts
import axios from "axios";
import "../_mock/index.ts";
const Demo: FC = () => {
  useEffect(() => {
    axios.get("/api/test").then((res) => console.log("axios data", res.data));
  }, []);
};
```

3. mockjs 具有**强大的 random 能力**，可以生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等。

缺点：

1. mockjs 体积很大，大于 50kb，上线时不要把 mockjs 打包进项目里
2. 上线之前要把引入的 mock 接口注释掉，以防线上接口也被 mock 数据拦截；该行为会造成开发时的心智负担
3. 只能劫持 XHR

不推荐在项目中直接使用 mockjs

#### nodejs 服务 + mock.js【推荐】

1. 新建一个 node 项目
2. 安装 `mockjs`，配置 mock 接口

   ```js
   // mock/question.js
   const Mock = require("mockjs");
   const Random = Mock.Random;
   module.exports = [
     {
       url: ".api/question/:id",
       method: "get",
       response() {
         return {
           errno: 0,
           data: {
             id: Random.id(),
             title: Random.ctitle(),
           },
         };
       },
     },
   ];

   // mock/index.js
   const question = require("./question");
   const mockList = [...question];
   module.exports = mockList;
   ```

3. 安装 `koa`、`koa-router`，创建 node 服务

   ```js
   // index.js
   const Koa = require("koa");
   const Router = require("koa-router");
   const mockList = require("./mock/index");

   const app = new Koa();
   const router = new Router();

   // 创建 mock 路由
   mockList.forEach((item) => {
     const { url, method, response } = item;
     router[method](url, async (ctx) => {
       const res = response();
       ctx.body = res;
     });
   });

   app.use(router.routes());
   app.listen(3001);
   ```

4. 安装 `nodemon`（可以检测到接口变化重启服务），创建命令启动 node 服务

   ```json
   "scripts": {
       "dev": "nodemon index.js"
     },
   ```

5. 在 react 项目中使用 node 服务，请求 mock 接口

   - 解决跨域：
     - 安装 craco（create-react-app-config-overwrite，即 CRA 项目配置重写）
     - 创建 `craco.config.js`，修改 `devServer.proxy`
       ```js
       module.exports = {
         devServer: {
           proxy: {
             "/api": "http://localhost:3001",
           },
         },
       };
       ```
     - 在 script 命令中，将`start`、`build`、`test`命令里的 `react-scripts` 替换成 `craco`
     - 重启项目后直接调用接口即可

nodejs 服务 + mock.js 的优势：

1. mock 服务与前端项目完全分离
2. 前端请求方式不再仅限于 XHR，fetch 同样适用
3. 可在后端延迟几秒返回数据，模拟 loading 效果
4. mock 接口可扩展性强
5. mockjs 的 Random 能力

#### 在线 mock 平台【不推荐】

1. 第三方在线 mock 平台：[Fast-mock](https://fastmock.site/#/)、[Y-API](https://hellosean1025.github.io/yapi/index.html)、[Swagger](https://swagger.io/) 等【不推荐】

   - 可能不稳定、不维护，或者网络不稳定
   - 可能存在数据泄露的风险

2. 企业内部服务平台【推荐】

### API 设计 - Restful API 规范

Restful API 的特点：

1. 资源：所有的数据和服务都被视为资源，每个资源都有一个唯一的标识符（通常是一个 URI）
2. 状态转移操作：常见的操作有 `GET`（获取）、`POST`（新增）、`PUT`（更新整体资源）、`PATCH`（更新局部资源）、`DELETE`（删除） 等
3. 统一接口：标准化的接口原则，可读性增强

### 接口封装

#### 封装 axios：

```ts
// services/ajax.ts
import axios from "axios";
import { message } from "antd";
const instance = axios.create({
  timeout: 10 * 1000,
});
// response拦截：处理 errno、 msg 和返回数据
instance.interceptors.response.use((res) => {
  const resData = (res.data || {}) as ResType;
  const { errno, data, msg } = resData;
  // 错误提示
  if (errno !== 0) {
    try {
      if (msg) {
        message.error(msg);
      }
      throw new Error(msg);
    } catch (error) {
      // 用catch捕获错误
      console.log("接口错误");
    }
  }
  return data as any;
});

export default instance;
export type ResType = {
  errno: number;
  data?: ResDataType;
  msg?: string;
};
export type ResDataType = {
  [key: string]: any;
};
```

#### 封装接口

```ts
// services/question.ts
import axios, { ResDataType } from "./ajax";

// 搜索参数
type SearchOption = {
  keyword: string;
  isStar: boolean;
  isDeleted: boolean;
  // pageSize
  // page
  // isPublished
  // ...
};
// 获取（查询）问卷列表
export async function getQuestionListService(
  opt: Partial<SearchOption>
): Promise<ResDataType> {
  const url = "/api/question";
  const data = (await axios.get(url, { params: opt })) as ResDataType;
  return data;
}
```

### 使用 useRequest 管理网络请求

**`useRequest`** 是 ahooks 提供的自定义 hook；它包含的能力有：

- 自动请求（默认）/手动请求 `run`
- `loading` 状态
- 错误处理 `error`
- 成功回调：`onSuccess`
- 重新执行：`refresh`
- 防抖：`debounceWait`
- ...

```js
const { loading, error, run } = useRequest(changeUsername, {
  manual: true, // 默认是自动请求，这里配置为通过执行run方法手动请求
  refreshDeps: [...], // 重新执行的依赖项
  //请求成功的回调
  onSuccess(result) {
    // ...
  },
  // 请求失败的回调
  onError() {
    // ...
  }
});
```

> **强烈建议使用 `useRequest` 来管理 React 项目中的请求，不必自己使用 `useState`、`useEffect` 去封装 `loading`、`error`、`useEffect` 等。**

### 分页功能/上拉加载更多

#### 分页

1. 使用 antd 组件 `Pagination` 实现分页
2. 从 `searchParams` 中读取 `page`、`pageSize`，设置到 `Pagination` 的 `current`、`pageSize` 中
3. 监听 `Pagination` 的 `onChange` 事件，修改 `searchParams` 中的 `page`、`pageSize`，然后使用 `useNavigate` 修改 url
4. 请求接口的 Hook - `useQuery` 监听到 `searchParams` 改变后重新获取数据，刷新页面

> 重点就是分页功能和列表数据通过 url 的 `searchParams` 进行联动，实现了**低耦合性**

#### 上拉加载

1. 封装一个 `加载更多组件` 来显示不同条件下的信息
2. 在 `LoadMoreElem` 上绑定一个 Ref，用来判断该组件是否出现在可视区域
3. 创建一个加载更多数据的方法 - `tryLoadMore`

   - 3.1 当页面初始化和搜索词`keyword`变化时重新执行该方法
   - 3.2 当页面滚动时，监听滚动，执行该方法

4. 将`tryLoadMore`设置成防抖函数
5. 滚动时，只有当 `LoadMoreElem` 出现在可视区域（初始化和滚动到数据底部时都符合）才加载更多数据
6. 使用 `useRequest` 封装获取数据的方法，加载更多数据成功后，重新设置 `page`（老数据加一）、`list`（**数据拼接**）
7. 修改搜索词时，通过重置 `list`、`page` 等信息来刷新数据

```ts
/**
 * 当searchParams变化时，会触发tryLoadMore方法，但由于 LoadMoreElem 不在可视区域，所以不会请求新的数据
 * 此时通过将list、total、started等全部清空来初始化页面，进而触发load方法重新加载数据
 */
useEffect(() => {
  setStarted(false);
  setPage(1);
  setList([]);
  setTotal(0);
}, [keyword]);

const { run: load, loading } = useRequest(
  async () => {
    const data = await getQuestionListService({
      page,
      pageSize: LIST_PAGE_SIZE,
      keyword,
    });
    return data;
  },
  {
    manual: true,
    onSuccess(result) {
      const { list: l = [], total = 0 } = result;
      setList(list.concat(l));
      setTotal(total);
      setPage(page + 1);
    },
  }
);

const containerRef = useRef<HTMLDivElement>(null);
// 加载更多：防抖函数
const { run: tryLoadMore } = useDebounceFn(
  () => {
    const elem = containerRef.current;
    if (elem === null) return;
    const domRect = elem.getBoundingClientRect();
    if (domRect === null) return;
    const { bottom } = domRect;
    /**
     * 1. 初始化时 LoadMoreElem 在最上面，所以会触发load方法请求数据
     * 2. 当 haveMoreData 存在，则滚动时，LoadMoreElem 出现在可视区域后会触发load方法，获取更多数据
     */
    if (bottom <= window.innerHeight) {
      load();
      setStarted(true);
    }
  },
  {
    wait: 500,
  }
);

// 1. 页面初次加载完成时 或 url参数（keyword）变化时，触发加载，加载第一页
useEffect(() => {
  tryLoadMore();
}, [searchParams, tryLoadMore]);
// 2. 页面滚动时，要尝试触发加载
useEffect(() => {
  if (haveMoreData) {
    // 监听滚动的回调函数（tryLoadMore）一定要做防抖处理
    window.addEventListener("scroll", tryLoadMore);
  }
  return () => {
    window.removeEventListener("scroll", tryLoadMore);
  };
}, [searchParams, tryLoadMore, haveMoreData]);

// LoadMoreElem
const LoadMoreContentElem = () => {
  if (!started || loading) return <Spin />;
  if (total === 0) return <Empty description="暂无数据" />;
  if (!haveMoreData) return <span>没有更多了...</span>;
  return <span>加载更多...</span>;
};
```

### JWT 登录

JWT(JSON Web Token)：

1. 登录成功后，服务器返回一个 token
2. 前端把它存储到浏览器内存(localStorage)中；
3. 通过 axios 拦截器设置请求头 `Authorization`，以后每次请求都带着这个 token 表明自己的身份。
4. 退出登录：移除内存中的 token 即可，下次请求接口时，接口就会报“未登录”的信息

## Redux 状态管理

为何需要状态管理：

- 页面足够复杂：组件很多，嵌套层级很深
- 通过 props 层层传递不合适
- 需要集中、统一管理页面数据

### Context

特点：

- 可跨层级传递数据，而不像 props 层层传递
- 类似于 Vue 的 provide/inject
- 使用场景：
  - 1. **统一下发全局变量，例如切换主题、切换语言等；**
  - 2. **结合`useReducer`实现数据的统一管理**

使用：

1. 创建上下文 - `createContext`
   ```tsx
   // 创建上下文
   const MyContext = React.createContext();
   // 导出 Provider 以便在组件中使用
   export const MyContextProvider = MyContext.Provider;
   ```
2. 提供上下文数据 - `<MyContext.Provider value={...}></MyContext.Provider>`，并且可以使用 state 管理这个全局变量

   ```tsx
   import { MyContextProvider } from "./path-to-your-context-file";
   function App() {
     const contextData = {
       /* your context data here */
     };
     return (
       <MyContextProvider value={contextData}>
         {/* Your app components go here */}
       </MyContextProvider>
     );
   }
   ```

3. 在子孙组件中使用 - `useContext`

   ```tsx
   import React, { useContext } from "react";
   import { MyContext } from "./path-to-your-context-file";
   function MyComponent() {
     // 使用 useContext 获取上下文数据
     const contextData = useContext(MyContext);

     // 然后可以在组件中使用 contextData
     return <div>{/* Render your component using contextData */}</div>;
   }
   ```

> 使用`useContext`时，当一个组件修改了数据（一般通过 Context 传递的函数来修改），另一个共享`Context`数据的组件也会重新渲染

### useReducer

特点：

- `useState` 的替代方案
- 数据结构简单时用 `useState`，复杂时用 `useReducer`
- 简化版的 Redux

使用：

1. `useReducer` 的第一个参数是 `reducer` 函数，第二个参数是初始状态；返回值包括当前状态和一个 `dispatch` 函数（用于触发状态更新 `action`）。
2. `reducer` 函数接收当前状态 `state` 和一个描述操作的 `action` 对象，返回一个新的状态。

```tsx
type StateType = {
  count: number;
};
type ActionType = { type: string };
const initialState: StateType = { count: 100 };
function reducer(state: StateType, action: ActionType) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}
const CountDemo: FC = () => {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <>
      {state.count}
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
    </>
  );
};
```

> 注意事项：
>
> 1. `useReducer` 可以跨组件共享数据，但是一个组件修改了数据，另一个**共享数据的组件不会重新渲染**，解决方式：
>    **结合 `Context`，将 `useReducer` 的 `state` 通过 `Context` 共享给其他组件**。
> 2. **`state` 和 `reducer` 函数没有模块化**，一般只适用于简单的数据结构

### Redux

Redux 相较于 `useReducer` 的优点：

- **默认支持跨组件通讯**，无需其他功能（例如 `Context`）协助
- Redux 的`store`、`reducer` 可以拆分模块，更适合复杂数据结构（`Context` + `useReducer` 适合简单数据结构）
- Redux 有开发者工具和插件，方便调试和开发

#### Redux Toolkit

Redux Toolkit（RTK）旨在简化 Redux 开发，并提供一些内置的工具来处理常见的 Redux 模式，包括 **Immer** 和**异步操作**。

> RTK 处理异步：TODO...

RTK 使用：

1. 创建 `count` 模块相关的 `reducer`：

```ts
// src/store/count.ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";
const INIT_STATE: number = 100;
export const countSlice = createSlice({
  name: "count", // 模块名
  initialState: INIT_STATE,
  reducers: {
    // 【*】action的类型是 PayloadAction<{ num: number }>，泛型是action的入参类型
    increase(state: number, action: PayloadAction<{ num: number }>) {
      const { num } = action.payload;
      return state + num; // 不可变数据
    },
    decrease(state: number) {
      return state - 1;
    },
  },
});
// 导出 count 模块的 actions
export const { increase, decrease } = countSlice.actions;
// 导出 count 模块的 reducer
export default countSlice.reducer;
```

2. 创建 `store`，并将各个模块的 `reducer` 导入根配置文件

```ts
// src/store/index.ts
import { configureStore } from "@reduxjs/toolkit";
import countReducer from "./count";
export type StateType = {
  count: number;
};
export default configureStore({
  reducer: {
    count: countReducer,
    // ... 扩展其他模块
  },
});
```

3. 在项目入口文件导入 store

```ts
// src/index.tsx
import { Provider } from "react-redux";
import store from "./store/index";

root.render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

4. 在组件中使用 store - **`useSelector`**、**`useDispatch`**

```tsx
import { useSelector, useDispatch } from "react-redux";
import { increase, decrease } from "./store/count";
import type { StateType } from "./store/index";
const Count: FC = () => {
  const count = useSelector<StateType>((state) => state.count);
  const dispatch = useDispatch();
  function add(n) {
    dispatch(increase(n));
  }
  // ...
};
```

**单向数据流**：点击事件 -> dispatch(action) -> 在 reducer 中结合 state 与 action.payload，产生新的 state -> UI 视图更新

### Mobx

Mobx 与 Redux 的区别：

1. 响应式：
   - Redux 必须遵循不可变数据，通过 dispatch action 的方式返回新的 state
   - Mobx 实现了**响应式**，不用遵循不可变数据，像 Vue 一样**声明式修改数据即可响应式更新视图**。
2. 数据源：
   - Redux 是单一数据源，采用集中管理的模式
   - Mobx 是多数据源模式

使用：

1. 安装依赖：`npm install mobx mobx-react --save`
2. 创建 store：
   - 新建文件 `store/Counter.ts`, 通过 `class` 创建一个 `Counter` 类
   - 使用 `makeObservable` 将类的方法和属性变成响应式的
   - 导出 `counter` 实例
   ```ts
   // store/Counter.ts
   import { action, makeObservable, observable } from "Mobx";
   class Counter {
     constructor() {
       // 参数1：target，把谁变成响应式（可观察）
       // 参数2：指定哪些属性或者方法变成可观察
       makeObservable(this, {
         count: observable,
         increment: action,
         double: computed,
         reset: action,
       });
     }
     count = 0;
     increment() {
       this.count++;
     }
     get double() {
       return this.count * 2;
     }
     reset() {
       this.count = 0;
     }
   }
   const counter = new Counter();
   export default counter;
   ```
3. 模块化
   1. 在 store 文件下创建`index.ts`文件，导入所有 `store`，组合成一个新 `RootStore`
   2. 使用 `Context`，自定义 `useStore` hook，统一导出 store
4. 在组件中使用 mobx：
   - 从 Mobx-react 库中引入 observer 高阶组件函数，
   - 使用 `observer` 高阶组件函数包裹需要使用 store 的组件
   - 在组件中引入 `store` 对象（可用 `useStore` 来导入）
   - 使用 store 对象中的属性和方法即可
5. 在 mobx 中使用异步
   1. 在外部调用异步接口，然后在返回数据处理逻辑内更新 `store`
   2. 或者在 Store 内定义 `async` 函数，可以使用 **`runInAction`** 更新 `state`

```ts
// store/index.ts
import { useContext, createContext } from 'react'
import cart from './Cart'
import counter from './Counter'
class RootStore {
  cart = cart
  counter = counter
}
const store = new RootStore()

// 创建一个上下文对象，用于跨级组件通讯
// // 如果 createContext 提供了默认值，不需要 Provider
const Context = createContext(store)
// 自定义 hooks
export const useStore = () => {
  return useContext(Context)
}

// xxx.tsx - 在组件中使用 store
import {useStore} from './store'
...
    const {cart, counter} = useStore()
...
```

> **`prompt(...)`** 浏览器的对话框提示

## 开发问卷编辑器

### 用两个组件打通全部流程

1. 创建画布组件
2. 编辑问卷数据
3. 请求接口，将问卷数据存储到 Redux 中

> `pointer-events: none;` // 屏蔽鼠标行为，组件不让被点击到

### 增加其他组件，展现设计的扩展性

### 聚焦高级功能：拖拽排序和撤销重做
